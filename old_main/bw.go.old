/*
 *   Copyright 2022 Martin Proffitt <mproffitt@choclab.net>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package main

import (
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"strings"

	"github.com/coreos/go-systemd/v22/dbus"

	"github.com/hokaccha/go-prettyjson"
	"github.com/notapipeline/bwv/pkg/config"
	"github.com/notapipeline/bwv/pkg/unix"
)

var (
	//loginResponse *bitw.LoginResponse
	//authToken     string
	appName string = "bwv"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage bwv [ serve [ --whitelist 127.0.0.1,192.168.1.1,...] <path>")
		return
	}

	var (
		path string
		c    interface{}
		s    server = server{
			c: config.Config{},
		}
		err error
	)

	path = os.Args[1]
	switch path {
	case "serve":
		s.listenAndServe()
	case "install":
		if err = unix.InstallService(appName); err != nil {
			log.Fatal(err)
		}
		if err = unix.StartService(appName); err != nil {
			log.Fatal(err)
		}
	case "remove":
		err = unix.RemoveService(appName)
	case "start":
		err = unix.StartService(appName)
	case "stop":
		err = unix.StopService(appName)
	case "status":
		var status *dbus.UnitStatus
		status, err = unix.ServiceStatus(appName)
		if err == nil {
			fmt.Println(status.SubState)
		}
	case "genkey":
		if len(os.Args) < 3 {
			fmt.Println("Please specify an IP or CIDR range for this key")
			return
		}

		if len(strings.Split(os.Args[2], ",")) != 1 {
			fmt.Println("Only a single IP or CIDR range should be provided")
			return
		}
		s.c.Load()
		if err = parseWhitelist(&s.c, os.Args[2], false); err == nil {
			var token string
			if token, err = s.c.AddApiKey(os.Args[2]); err != nil {
				log.Fatal(err)
			}
			fmt.Printf(
				"\n========================================\ntoken = %s"+
					"\n========================================\n\n",
				token)

		}
	case "revoke":
		var ip string
		if len(os.Args) < 3 {
			fmt.Println("Please specify the api key or ip/range to revoke")
			return
		}
		if err = s.c.Load(); err != nil {
			log.Fatal(err)
		}

		ip, err = s.c.RevokeApiKey(os.Args[2])
		if err != nil {
			log.Fatal(err)
		}

		if ip != "" {
			err = parseWhitelist(&s.c, ip, true)
		}
	case "whitelist":
		if err = s.c.Load(); err != nil {
			log.Fatal(err)
		}

		err = parseWhitelist(&s.c, os.Args[2], false)
	case "drop":
		s.c.Load()
		err = parseWhitelist(&s.c, os.Args[2], true)
	default:
		log.SetOutput(io.Discard)
		s.c.Load()
		if c = client(path, s.c.Port, s.IsSecure(), false); c == nil {
			return
		}
		// print server config
		str, e := prettyjson.Marshal(c)
		if e != nil {
			log.Fatal(e)
		}
		fmt.Println(string(str))
		return
	}
	if err != nil {
		log.Fatal(err)
	}
	var reloadCommands []string = []string{
		"genkey", "revoke",
		"whitelist", "drop",
	}
	if contains(os.Args[1], reloadCommands) && isRunning() {
		client("bwvreload", s.c.Port, s.c.IsSecure(), false)
	}
}

func parseWhitelist(conf *config.Config, w string, remove bool) error {
	var whitelist []string = strings.Split(w, ",")
	for _, addr := range whitelist {
		if net.ParseIP(os.Args[2]) == nil {
			ip, n, err := net.ParseCIDR(addr)
			if err != nil {
				return fmt.Errorf("Invalid IP or cidr range %s\n", addr)
			}
			if !n.IP.Equal(ip) {
				return fmt.Errorf("Cidr range %s is invalid, should be %s\n", addr, n)
			}
		}

		if remove {
			var newWhitelist []string = make([]string, 0)
			for _, netw := range conf.Whitelist {
				if netw == addr {
					continue
				} else if config.ContainsIp(netw, addr) {
					return fmt.Errorf("Address %s is part of CIDR range %s which is not being removed", addr, netw)
				}
				newWhitelist = append(newWhitelist, netw)
			}
			conf.Whitelist = newWhitelist
		} else {
			var exists bool = false
			for _, netw := range conf.Whitelist {
				if addr == netw || config.ContainsIp(netw, addr) {
					exists = true
				}
			}
			if !exists {
				conf.Whitelist = append(conf.Whitelist, addr)
			}
		}
	}
	conf.Save()
	return nil
}

func isRunning() bool {
	var (
		status *dbus.UnitStatus
		err    error
	)
	status, err = unix.ServiceStatus(appName)
	return err == nil && status.SubState == "running"
}
